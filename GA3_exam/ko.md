학업 성취도 평가를 치던 운영자는 문제를 다 풀고 할 것이 없어 종이에 아름다운 그림들을 그리다가, 이 문제를 고안해 냈습니다.

당신에게 $0$부터 $N - 1$까지의 번호가 붙은 $N$개의 문제가 있는 시험지와 답안지가 있습니다. 시험은 5지 선다형이며, 문제 $i$의 답은 무조건 1 이상 5 이하의 자연수  $A[i]$입니다. 또, 임의의 문제 $i$에는 그 문제의 점수 $S[i]$가 주어집니다. 편의상 모든 문제의 점수는 자연수라고 가정합시다.

여기까지 어느 시험과 다를 바가 없지만, 다른 점이 하나 있다면, ***시험지에 시험 문제가 없다***는 것입니다. 운영자는 모든 문제를 찍어서 제출하는 사태를 막기 위해 ***최대 $K$번의 채점 기회***를 드렸습니다. 채점은 답안지에 몇 문제의 답안을 표기하면, 기계가 이를 채점하여 점수를 돌려주는 방식으로 진행됩니다.


### 해야 할 일

당신은 당연히 점수를 최대화시키고 싶…겠죠? 그러니 당신이 받을 점수를 최대화하는 데에 도움을 주는 함수 `GetBestAnswer(N, S, K)` 을 작성합시다!

* `N`은 문제의 수입니다.
* `S`는 크기 `N`의 배열입니다. `0` 이상 `N - 1` 이하의 `i`에 대해, `S[i]`는 `i`번 문제의 점수입니다.
* `K`는 가능한 채점의 최대 횟수입니다.

당신에게 채점의 기회를 드리기 위해 아래와 같은 함수들을 만들었습니다.

* `Mark(n, a)` - 답안지에 `n`번 문제의 답을 `a`로 표기합니다. `n`은 `0` 이상 `N - 1` 이하의 정수, `a`는 `1` 이상 `5` 이하의 자연수여야만 합니다. 또한, 이미 답안을 표기한 문제에 (같은 답이라도) 한 번 더 표기할 수 없습니다. 
* `GetScore()` - `Mark`를 통해 답안지에 표기한 답안을 채점했을 때의 점수를 돌려줍니다. 이 함수를 호출하면 답안지가 새로 지급되어, 빈 상태가 됩니다.

위 두 함수를 이용해서 최대 점수를 받을 수 있는 답안을 만들었고, 이 답안들을 `B[0], B[1], ..., B[N - 1]`이라고 가정해 봅시다. 답안지를 제출하기 위해서는 `Report(B[0]), Report(B[1]), ..., Report(B[N-1])`을 차례로 호출해야 합니다. `Report` 함수를 호출한 뒤 `GetScore`나 `Mark` 함수를 호출할 수 없으며, 함수의 인자로 1 이상 5 이하의 자연수만을 넘길 수 있습니다.

위 조건을 만족하지 않을 시 프로그램이 강제로 종료되며, 아래 채점 기준에 따라 점수를 덜 받을 수도 있습니다.


### 예제

시험 문제가 $N = 5$문제이고, 각 문제의 답과 그 점수가 아래와 같다고 가정해 보겠습니다.

<center>

|   |0|1|2|3|4|
|---|-|-|-|-|-|
|$A$|3|2|5|1|5|
|$S$|5|4|5|3|3|

</center>

아래와 같이 답안지 $T$에 몇 개의 문제의 답안을 표기했다고 가정합시다.

<center>

|   |0|1|2|3|4|
|---|-|-|-|-|-|
|$T$|2|2|X|1|4|

</center>

위와 같이 답안을 표기하기 위해서는 `Mark(0, 2)`, `Mark(1, 2)`, `Mark(3, 1)`, `Mark(4, 4)`를 호출하면 됩니다. (꼭 *순서대로 호출할 필요는 없습니다*) 이 상황에서 `GetScore()`를 호출하면 `1`번 문제와 `3`번 문제가 정답이므로 `S[1] + S[3] = 4 + 3 = 7`을 돌려주며, 답안지의 상태는 아래와 같이 변합니다.

<center>

|   |0|1|2|3|4|
|---|-|-|-|-|-|
|$T$|X|X|X|X|X|

</center>

이후 여러 과정을 거쳐 아래와 같은 최종 답안 $B$을 만들었다고 가정합시다.

<center>

|   |0|1|2|3|4|
|---|-|-|-|-|-|
|$B$|3|3|5|1|5|

</center>

이 최종 답안을 제출하기 위해서는 `Report(3)`, `Report(3)`, `Report(5)`, `Report(1)`, `Report(5)`를 *차례대로* 호출해야 합니다.

### 서브태스크

모든 입력에서 `N`은 100 이하의 10의 배수이고, `0` 이상 `N - 1` 이하의 `i`에 대해 `1 ≤ S[i] ≤ 9`임이 보장됩니다. 

#### 서브태스크 1 (10점)

* `K = 5N`
* 주어지는 모든 데이터에서 만점을 받아야 10점을 획득할 수 있습니다.

#### 서브태스크 2 (20점)

* `K = 4N`
* 주어지는 모든 데이터에서 만점을 받아야 20점을 획득할 수 있습니다.

#### 서브태스크 3 (27점)

* `K = 3N`
* 주어지는 모든 데이터에서 만점을 받아야 27점을 획득할 수 있습니다.

#### 서브태스크 4 (43점)

* `K = 2N`

* 여러분의 프로그램이 주어지는 모든 데이터에서 만점의 $L$배 이상을 받았다면, 아래 채점 기준에 따라 점수를 획득하실 수 있습니다.
 - $L = 1$: 43점
 - $0.5 < L < 1$: $(L - 0.5) \times 80$점
 - $L < 0.5$: 0점
 
* 토큰을 사용하시면, 이 서브 태스크에서 grader output의 열에는 $L$의 값이 적힙니다.

#### 보너스 서브태스크 5 (60점)

* `K = 1.5N`

* 다른 문제들이 너무 쉬워서 다 푸신 분들(?)을 위해 마련한 서브태스크이며, 출제자도 이 서브태스크의 정해는 모릅니다.

* 이 서브태스크의 채점 데이터는 총 3,000개입니다. 데이터 중 2,000개는 랜덤 데이터이며, 1,000개는 운영자가 임의로(?) 만든 데이터입니다.

* 각 데이터당 0.02점의 점수가 배당되었으며, 이 서브태스크의 점수는 모든 데이터에서 받은 점수의 합이 됩니다. 임의의 데이터에 대해 여러분의 프로그램이 만점의 $L$배를 받았다면, 아래 채점 기준에 따라 그 데이터의 점수가 매겨집니다.

 - $0.2 \le L \le 1$: $0.02L$점
 - $L < 0.2$: 0점
 
* 토큰을 사용하시면, 이 서브 태스크에서 grader output의 열에는 모든 데이터에서 받은 점수의 합이 적힙니다.

### 구현 시 유의사항

#### 채점 환경

* 실제 채점 시 함수 `GetBestAnswer`는 한 번 프로그램을 실행할 때마다 200번씩 호출됩니다. 따라서, 함수를 여러 번 호출함으로써 발생할 수 있는 초기화 문제를 잘 신경 써야 합니다.
* 프로그램의 최대 실행 시간은 1.5초입니다. (1.5초 안에 200번 호출) 채점 프로그램의 실행 시간이 0.3초를 넘지 않음이 보장되어 있습니다.
* 메모리 제한은 64MB이며, 스택 메모리 역시 전체 메모리에 포함됩니다.

#### 인터페이스

**<u>[여기](https://s3.ap-northeast-2.amazonaws.com/oj.uz/old/GA3_exam/grader.zip)</u>**를 클릭하시면 개발에 필요한 인터페이스가 제공됩니다. 이를 이용해서 이 문제를 좀 더 쉽게 해결할 수 있을 것입니다. 아래에 그 설명이 있습니다.

* 작성해야 할 파일: `exam.c` 또는 `exam.cpp`
* 채점 프로그램 인터페이스: `grader.h`
* 견본 채점 프로그램: `grader.c` 또는 `grader.cpp`
* 컴파일 쉘(gcc): `compile_c.sh` 또는 `compile_cpp.sh`

견본 채점 프로그램은 표준 입력(stdin)으로 입력을 받으며, 그 양식은 아래와 같습니다.

* 1번째 줄: `N`
* 2번째 줄: `K`
* 3번째 줄: 각 문제의 답안 `A[0], A[1], .., A[N-1]`
* 4번째 줄: 각 문제의 점수 `S[0], S[1], .., S[N-1]`

견본 채점 프로그램은 표준 출력(stdout)으로 **(프로그램이 구한 답안의 점수) / (만점)**의 값이 소수점 아래 7번째 자리까지 한 줄에 출력합니다.
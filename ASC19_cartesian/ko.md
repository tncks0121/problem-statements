특별한 이진 검색 트리인 *Cartesian Tree*를 다루어 봅시다. 이진 검색 트리는 루트가 있는 이진 트리로서, 모든 노드 $u$에 다음 조건을 만족합니다: 왼쪽 서브트리의 모든 노드의 키(key) 값은
 $u$의 키 값보다 작고, 오른쪽 서브트리의 모든 노드의 키는 $u$의 키 값보다 큽니다.

다시 말해, $L(u)$를 $u$의 왼쪽 서브 트리, $R(u)$를 $u$의 오른쪽 서브 트리, 키 값을 $x_{u}$로 두면 모든 노드 $u$에 대해서 $v \in L(u)$이면 $x_{v} < x_{u}$이고, $v \in R(u)$이면 $x_{v} > x_{u}$라는 것입니다.

이진 검색 트리가 *Cartesian Tree*라고 불리기 위해서는, 모든 노드 $u$가 주요 키 값 $x_{u}$ 이외 보조 키  $y_{u}$를 가지고 있고, 이 보조 키들은 힙 (heap) 조건을 만족해야 합니다. 즉, 만약 $v$가 $u$의 부모 노드라면 $y_{v} < y_{u}$를 만족해야 합니다.

한편으로, 숫자 쌍들의 집합 $(x_{1}, y_{1}), (x_{2}, y_{2}), \cdots, (x_{n}, y_{n})$을 *올바르다*고 하려면 모든 $x_{i}$가 $1$ 이상 $n$ 이하의 서로 다른 수들이고, 모든 $y_{i}$가 $1$ 이상 $n$ 이하의 서로 다른 수들이면 됩니다. 올바른 숫자 쌍들의 집합이 있다면 이들을 이용해 만들 수 있는 유일한 Cartesian Tree가 존재함을 쉽게 증명할 수 있습니다.

$n$개의 노드들로 구성된 루트가 있는 이진 트리 $T$를 고려해 봅시다. 여러분이 해야 할 일은 올바른 숫자 쌍의 집합들 중 *Cartesian Tree*를 만들었을 때 주어진 이진 트리와 똑같아지는 집합의 개수를 구하는 것입니다.

예로 들어, *Cartesian Tree*를 만들어 아래 그림과 같아지는 올바른 집합들은 $\\{(1, 2),(2, 3),(3, 1),(4, 4)\\}, \\{(1, 2),(2, 4),(3, 1),(4, 3)\\}, \\{(1, 3),(2, 4),(3, 1),(4, 2)\\}$의 3가지가 있습니다.

<div style="text-align: center;">
 <img src="https://s3.ap-northeast-2.amazonaws.com/oj.uz/old/ASC19_cartesian/tree.png"/>
</div>

### 입력 형식

첫 번째 줄에는 트리 $T$의 노드의 수 $n$ ($1 \le n \le 200$)이 주어집니다. 다음 $n$개 줄에는 트리 $T$의 노드에 대한 개략적인 정보가 주어집니다. 이 중 $i$번째 줄에는 $i$번 노드의 왼쪽 자식 노드의 번호와 오른쪽 자식 노드의 번호가 공백을 사이로 두고 주어집니다. 만약 해당 노드가 없다면, 번호는 0으로 대체됩니다. 입력은 정확함이 보장됩니다. 루트 노드의 번호는 1번입니다.

### 출력 형식

첫 번째 줄에 $T$가 Cartesian tree가 되도록 하는 올바른 숫자 쌍들의 집합의 수를 출력합니다.

### 예제

<table class='table table-bordered table-condensed'>
 <thead>
  <tr>
   <th style="width: 50%;">입력</th>
   <th style="width: 50%;">출력</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td class="code-font">4<br/>
2 3<br/>
0 4<br/>
0 0<br/>
0 0</td>
   <td class="code-font">3</tr>
 </tbody>
</table>
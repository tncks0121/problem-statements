병합 정렬은 분할 정복 기법을 사용하는 아주 유명한 정렬 알고리즘입니다. 이 알고리즘은 이렇게 동작합니다.

알고리즘은 재귀적으로 동작하며, 배열의 구간을 정렬합니다. 두 개의 파라미터 $l$과 $r$이 있는데, 이는 알고리즘이 정렬할 구간의 왼쪽 끝 위치가 $l$이고 오른쪽 끝 위치가 $r$임을 의미합니다. 만약 정렬할 원소가 하나뿐이라면, 알고리즘은 아무것도 시행하지 않습니다. 그렇지 않다면, 구간은 $l$에서부터 $m$까지의 구간과 $m+1$부터 $r$까지의 구간, 총 두 개의 구간으로 나뉩니다. 이 때 $m = \lfloor (l+r)/2 \rfloor$이며, 이렇게 나뉜 두 배열은 재귀적으로 정렬되었다고 가정합니다.

이제 두 개의 정렬된 구간을 합쳐야 합니다. 두 개의 포인터가 사용되는데, 하나는 첫 번째 구간에 대한 것이고, 또 다른 하나는 두 번째 구간에 대한 것입니다. 맨 처음 두 포인터는 모두 두 구간의 가장 작은 원소를 가리킵니다. 각 단계마다 두 개의 포인터가 가리키는 값을 비교하여, 더 작은 값은 임시 배열의 맨 끝에 저장되며, 포인터는 오른쪽으로 한 칸 이동합니다. 만약 두 포인터 중 하나가 구간 밖으로 벗어나면, 다른 구간의 남은 부분은 임시 배열 끝으로 복사됩니다. 이제 임시 배열에 저장된 값들을 원래 배열로 옮기면, 이 구간은 정렬되었습니다.

$n$개의 원소가 들어 있는 배열을 정렬하려면, 위 알고리즘을 $l = 1, r = n$인 상태에서 시행하면 됩니다.

병합 정렬에서 두 개의 원소를 비교하는 횟수는 원래 배열에 따라 바뀐다는 것을 명심하세요. 예로 들어, 길이가 $k$인 구간을 정렬하고 있는 상태라고 가정해 봅시다. 현재 길이가 $k \div 2$인 두 구간으로 나뉘어 있습니다. 만약 첫 번째 구간의 원소가 모두 두 번째 구간의 원소보다 작다면, $k \div 2$번의 비교만으로 정렬할 수 있습니다. 하지만 원소들이 섞여 있다면, 최대 $k - 1$번의 비교가 일어납니다.

이 문제에서 우리는 $1$부터 $n$까지의 서로 다른 자연수가 들어 있는 길이가 $n$인 배열을 정렬하고자 합니다. 여러분은 위에서 서술한 병합 정렬 알고리즘에서 필요한 최대 비교 횟수를 알아내고, 비교 횟수가 최대가 되는 배열들 중 사전순으로 가장 작은 배열을 찾고, 이러한 배열의 수가 몇 개인지 알아내는 프로그램을 작성해야 합니다.

배열 $(a_{1}, a_{2}, \cdots, a_{n})$이 배열 $(b_{1}, b_{2}, \cdots, b_{n})$보다 사전순보다 작으려면, $a_{1}=b_{1}, a_{2}=b_{2}, \cdots, a_{i-1}=b_{i-1}, a_{i}<b_{i}$를 만족하는 $i$가 존재하면 됩니다.

### 입력 형식

$n$이 주어집니다. ($1 \le n \le 200$)

### 출력 형식

첫 번째 줄에 길이가 $n$인 서로 다른 원소가 들어 있는 배열을 병합 정렬 알고리즘으로 정렬하기 위해 필요한 최대 비교 횟수를 출력합니다.

두 번째 줄에 비교 횟수가 최대가 되는 배열들 중 사전순으로 가장 작은 배열을 출력합니다.

세 번째 줄에 비교 횟수가 최대가 되는 배열들의 수를 출력합니다.

### 예제

<table class='table table-bordered table-condensed'>
 <thead>
  <tr>
   <th style="width: 50%;">입력</th>
   <th style="width: 50%;">출력</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td class="code-font">4</td>
   <td class="code-font">5<br>1 3 2 4<br>16</td>
  </tr>
  <tr>
   <td class="code-font">5</td>
   <td class="code-font">8<br>1 2 4 3 5<br>48</td>
  </tr>
 </tbody>
</table>